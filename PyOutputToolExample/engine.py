import AlteryxPythonSDK
import xml.etree.ElementTree as ET
import os


class AyxPlugin:
    def __init__(self, n_tool_id, engine_interface, generic_engine, output_anchor_mgr):
        # initialize *all* members that will be used.

        # miscellaneous variables
        self.n_tool_id = n_tool_id
        self.name = str('PyOutputToolExample_') + str(self.n_tool_id)
        self.closed = False
        self.initialized = False

        # engine handles
        self.alteryx_engine = engine_interface
        self.generic_engine = generic_engine

        # record management
        self.record_info_in = None

        # custom members
        self.str_file_path = None
        self.field_names = None
        self.all_records = ''
        return

    # output_message notifies the Alteryx engine of any message generated by a tool.
    def output_message(self, method, status, message):
        self.alteryx_engine.output_message(self.n_tool_id, status, method + ': ' + str(message))

    # pi_init will be called when the Engine is ready to give us the tool configuration from the GUI.
    def pi_init(self, str_xml):
        try:
            root = ET.fromstring(str_xml)
            self.str_file_path = root.find('fileOutputPath').text # Getting the dataName data property from the GUI configuration
        except AttributeError:
            self.output_message('pi_init', AlteryxPythonSDK.EngineMessageType.error, 'Invalid XML: ' + str_xml)
            raise

        self.initialized = True
        return

    # pi_add_incoming_connection will be called when the Alteryx engine is attempting to add an incoming data connection.
    def pi_add_incoming_connection(self, str_type, str_name):
        return self

    # pi_add_outgoing_connection will be called when the Alteryx engine is attempting to add an outgoing data connection.
    def pi_add_outgoing_connection(self, str_name):
        self.output_message(
            'ii_push_record'
            , AlteryxPythonSDK.EngineMessageType.error
            , 'This tool does not accept an Outgoing Connection'
        )
        return True

    # pi_push_all_records will be called when the Alteryx engine when it's expecting the plugin to provide all of its data.
    def pi_push_all_records(self, n_record_limit):
        self.output_message(
            'pi_push_all_records'
            , AlteryxPythonSDK.EngineMessageType.error
            , 'Missing Incoming Connection'
        )
        return False

    # pi_close will be called prior to the destruction of the tool object represented by the plugin, once all records have been processed.
    def pi_close(self, b_has_errors):
        return

    # ii_init will be called when an incoming connection has been initalized and has told the Engine what its output will look like. record_info_in represents what the incoming record will look like.
    def ii_init(self, record_info_in):
        self.record_info_in = record_info_in # Storing the argument being passed to record_info_in parameter
        self.field_names = ','.join([field.name for field in record_info_in]) # extracting all the field names from record_info_in to a list in self.field_names
        self.field_names = self.field_names.replace('\n', '') # replace the newline characters in field names if they exist
        self.initialized = True
        return True

    # ii_push_record will be called every time we get a new record from the upstream tool
    def ii_push_record(self, in_record):
        if self.initialized is not True:
            return False
        # null_to_str extracts each record for the field passed in as a string from record_in, nulls get converted to string
        def null_to_str(field, in_record):
            ret = field.get_as_string(in_record)
            if ret is None:
                return ''
            return ret

        all_records = ','.join([null_to_str(field, in_record) for field in self.record_info_in]) # looping through null_to_str for each field in record_info_in to get a list of data points for the nth record
        self.all_records += all_records + ' \n' # Appending each record in csv format to self.all_records

        return True

    # ii_update_progress will be called periodically from the upstream tools, where they will tell us how far along
    #   they are in processing their data. If our tool needs to do any custom logic about how much work it has left to
    #   do, that logic should happen in here

    def ii_update_progress(self, d_percent):
        self.alteryx_engine.output_tool_progress(self.n_tool_id, d_percent)
        return

    # ii_close will be called when the incoming connection has finished passing all of its records

    def ii_close(self):
        if (self.str_file_path == None):
            self.output_message('Error ', AlteryxPythonSDK.EngineMessageType.error, 'Please enter a file path.')
        else:
            if (self.all_records != ''):
                if os.access(self.str_file_path, os.F_OK):
                    self.output_message('Error ', AlteryxPythonSDK.EngineMessageType.error, self.str_file_path + ' already exists. Please enter a different path.')
                else:
                    with open(self.str_file_path, 'a') as testfile:
                        testfile.write(self.field_names + '\n' + self.all_records)
                        testfile.close()
                        message = self.str_file_path + ' was written.'
                        self.output_message('Output ', AlteryxPythonSDK.EngineMessageType.info, message)
        return
